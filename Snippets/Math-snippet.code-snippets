{
	"Diophantine Equation Solver": {
		"prefix": "dioeq",
		"body": [
			"// Diophantine Equation Solver: solves ax + by = c",
			"ll extended_gcd(ll a, ll b, ll &x, ll &y) {",
			"    if (b == 0) { x = 1; y = 0; return a; }",
			"    ll x1, y1;",
			"    ll g = extended_gcd(b, a % b, x1, y1);",
			"    x = y1;",
			"    y = x1 - (a / b) * y1;",
			"    return g;",
			"}",
			"",
			"// Solves ax + by = c, returns one solution in x and y",
			"bool solve_diophantine(ll a, ll b, ll c, ll &x, ll &y, ll &g) {",
			"    g = extended_gcd(a, b, x, y);",
			"    if (c % g != 0) return false;",
			"    x *= c / g;",
			"    y *= c / g;",
			"    return true;",
			"}",
			"",
			"// Usage in main:",
			"ll a, b, c, x, y, g;",
			"cin >> a >> b >> c;",
			"if (solve_diophantine(a, b, c, x, y, g)) {",
			"    cout << \"One solution: x = \" << x << \", y = \" << y << \"\\n\";",
			"    cout << \"General solution: x = \" << x << \" + k * (\" << b / g << \"), y = \" << y << \" - k * (\" << a / g << \")\\n\";",
			"} else {",
			"    cout << \"No integer solution exists.\\n\";",
			"}"
		],
		"description": "Solves ax + by = c using Extended Euclidean Algorithm"
	},
	"First n Primes Generator": {
		"prefix": "sieve",
		"body": [
			"vector<int> sieve(int n) {",
			"    int limit = (n <= 5) ? 20 : n * (log(n) + log(log(n))) + 5;",
			"    vector<bool> is_prime(limit + 1, true);",
			"    vector<int> primes;",
			"    is_prime[0] = is_prime[1] = false;",
			"",
			"    for (int i = 2; i <= limit && primes.size() < n; ++i) {",
			"        if (is_prime[i]) {",
			"            primes.pb(i);",
			"            for (int j = i * 1LL * i; j <= limit; j += i)",
			"                is_prime[j] = false;",
			"        }",
			"    }",
			"    return primes;",
			"}"
		],
		"description": "Generates the first n prime numbers using sieve"
	},
	"Binary Exponentiation": {
		"prefix": "binpow",
		"body": [
			"// Binary Exponentiation (a^b % m)",
			"ll binpow(ll a, ll b, ll m = MOD) {",
			"    a %= m;",
			"    ll res = 1;",
			"    while (b > 0) {",
			"        if (b & 1) res = res * a % m;",
			"        a = a * a % m;",
			"        b >>= 1;",
			"    }",
			"    return res;",
			"}"
		],
		"description": "Efficiently computes (a^b) % m using binary exponentiation"
	},
	"Modular Inverse": {
		"prefix": "modinv",
		"body": [
			"// Binary Exponentiation (a^b % m)",
			"ll binpow(ll a, ll b, ll m = MOD) {",
			"    a %= m;",
			"    ll res = 1;",
			"    while (b > 0) {",
			"        if (b & 1) res = res * a % m;",
			"        a = a * a % m;",
			"        b >>= 1;",
			"    }",
			"    return res;",
			"}",
			" ",
			"// Modular Inverse using Fermat's Little Theorem (a^-1 % m)",
			"ll modinv(ll a, ll m = MOD) {",
			"    return binpow(a, m - 2, m);",
			"}"
		],
		"description": "Computes modular inverse of a modulo m assuming m is prime"
	},
	"Precompute Factorials and nCr": {
		"prefix": "ncr",
		"body": [
			"// Binary Exponentiation (a^b % m)",
			"ll binpow(ll a, ll b, ll m = MOD) {",
			"    a %= m;",
			"    ll res = 1;",
			"    while (b > 0) {",
			"        if (b & 1) res = res * a % m;",
			"        a = a * a % m;",
			"        b >>= 1;",
			"    }",
			"    return res;",
			"}",
			"",
			"// Modular Inverse using Fermat's Little Theorem (a^-1 % m)",
			"ll modinv(ll a, ll m = MOD) {",
			"    return binpow(a, m - 2, m);",
			"}",
			"",
			"//--------- Precompute Factorial and nCr -------------",
			"vector<int> fact, inv_fact;",
			"void precompute_factorials(int n = N6, int m = MOD) {",
			"    fact.assign(n + 1, 1);",
			"    inv_fact.assign(n + 1, 1);",
			"    for (int i = 2; i <= n; ++i)",
			"        fact[i] = 1LL * fact[i - 1] * i % m;",
			"    inv_fact[n] = modinv(fact[n], m);",
			"    for (int i = n - 1; i >= 0; --i)",
			"        inv_fact[i] = 1LL * inv_fact[i + 1] * (i + 1) % m;",
			"}",
			"",
			"int nCr(int n, int r, int m = MOD) {",
			"    if (r < 0 || r > n) return 0;",
			"    return 1LL * fact[n] * inv_fact[r] % m * inv_fact[n - r] % m;",
			"}"
		],
		"description": "Precomputes factorials and calculates nCr modulo MOD"
	},
	"Fast Power (a^b no mod)": {
		"prefix": "pow",
		"body": [
			"// Fast Exponentiation (a^b without mod)",
			"ll binpow(ll a, ll b) {",
			"    ll res = 1;",
			"    while (b > 0) {",
			"        if (b & 1)",
			"            res *= a;",
			"        a *= a;",
			"        b >>= 1;",
			"    }",
			"    return res;",
			"}"
		],
		"description": "Computes a^b using fast exponentiation without modulus"
	}
}